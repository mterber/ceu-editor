grammar org.xtext.ceu.Ceu with org.eclipse.xtext.common.Terminals

generate ceu "http://www.xtext.org/ceu/Ceu"

Root:
	Expression;
	
Expression:
	LogicOr
;

LogicOr returns Expression:
	LogicAnd ({LogicOr.left=current} op='or' right=LogicAnd)*
;

LogicAnd returns Expression:
	Compare ({LogicAnd.left=current} op='and' right=Compare)*;
	
Compare returns Expression:
	BinaryOr ({Compare.left=current} op=('!=' | '==' | '<=' | '>=' | '<' | '>') right=BinaryOr)*
;

BinaryOr returns Expression:
	BinaryXor ({BinaryOr.left=current} op='|' right=BinaryXor)*
;

BinaryXor returns Expression:
	BinaryAnd ({BinaryXor.left=current} op='^' right=BinaryAnd)*
;

BinaryAnd returns Expression:
	Shift ({BinaryAnd.left=current} op='&' right=Shift)*
;

Shift returns Expression:
	Addition ({Shift.left=current} op=('>>' | '<<') right=Addition)*
;

Addition returns Expression:
	Multiplication ({Addition.left=current} op=('+' | '-') right=Multiplication)*
;

Multiplication returns Expression:
	Unary ({Multiplication.left=current} op=('*' | '/' | '%') right=Unary)*
;

Unary returns Expression:
	( op+=('not' | '-' | '+' | '~' | '*' | '&&' | '&' | '$$' | '$') | (=>'(' cast+=Cast ')') )* right=Misc
;

Misc returns Expression:
	Primary
	( 
		( '(' (expList+=ExpList)? ')' ('finalize' 'with' finally+=Finally 'end')? ) |
		( '[' exps+=Expression ']' ) |
		( (':' | '.') __ID_FIELD ) |
		'?' | '!'
	)*
;

Primary returns Expression:
	'(' Expression ')' |
	//| a=Sizeof
	name=Var |
	name=Nat |
	key=Null |
	num=Number |
	str=STRING |
	key=Global |
	key=This |
	key=Outer |
	RawExp |
	//Vector_constr
	('call' Expression)
	//| ('call/rec' __Exp)
;

Cast returns Expression:
	Type | {Annotation} name=('@nohold' | '@plain' | '@pure');

Sizeof returns Expression:
	'sizeof' '(' (=>Type | Expression) ')'
;
Number:
	INT | FLOAT | HEX | 'true' | 'false';

Var:
	__ID_VAR
;
Nat:
	__ID_NAT
;
Null:
	'null'
;
Global:
	'global'
;
This:
	'this'
;
Outer:
	'outer'
;
RawExp:
	'{' __raw '}'
;

__raw: // TODO
	'c-code'
;
Vector_constr:
	tups+=Vector_tup ( '..' (tups+=Vector_tup /*| exps+=Expression*/) )*
;

Vector_tup:
	'[' ExpList ']'
;

Type:
	__ID_Type ( '&&' | '&' | '?' | ('[' (exp+=Expression)? ']') )*;

__ID_Type returns Type:
	name=(TYPES | __ID_NAT | __ID_CLS_ADT);

ExpList returns __Exp:
	Expression ({ExpList.first=current}',' next=Expression)*
;

Finally:
	val=INT//Block
;

terminal TYPES:
	'bool' | 'byte' | 'char' | 'f32' | 'f64' | 'float' | 'int' | 's16' | 's32' | 's64' | 's8' | 'u16' | 'u32' | 'u64' |
	'u8' | 'uint' | 'void' | 'word';
	
terminal __ID_VAR:
	'a'..'z' ALPHANUM*;

terminal __ID_EXT_TAG:
	'A'..'Z' ALPHANUM_L*;

terminal __ID_CLS_ADT:
	'A'..'Z' ALPHANUM*;

terminal __ID_NAT:
	'_' ALPHANUM+;

terminal __ID_FIELD:
	ALPHA ALPHANUM*;
	
terminal HEX:
	'0' ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;

terminal FLOAT:
	INT '.' INT (('e' | 'E') '-'? INT)?;

terminal fragment ALPHA: // Alpha
	'a'..'z' | '_' | 'A'..'Z';

terminal fragment ALPHANUM: // Alphanum
	ALPHA | '0'..'9';

terminal fragment ALPHANUM_L: // ALPHANUM
	'A'..'Z' | '_' | '0'..'9';

terminal fragment ALPHANUM_S: // alphanum
	'a'..'z' | '_' | '0'..'9';
/*
__8 returns __Exp:
	__9 ({OperationBinary.operandLeft=current} operator=('+' | '-') operandRight=__9)*;

__9 returns __Exp:
	__10 ({OperationBinary.operandLeft=current} operator=('*' | '/' | '%') operandRight=__10)*;

__10 returns __Exp:
//	( {OperationUnary} ( operators+=('not' | '-' | '+' | '~' | '*' | '&&' | '&' | '$$' | '$') | ('(' cast+=__Cast ')') )+ operand=__11 )
//	| __11;
	( operators+=('not' | '-' | '+' | '~' | '*' | '&&' | '&' | '$$' | '$') | ('(' cast+=__Cast ')') )* operand=__11;

__11 returns __Exp:
	__12
	( 
		( '(' (expList+=ExpList)? ')' ('finalize' 'with' finally+=Finally 'end')? ) |
		( '[' exps+=__Exp ']' ) |
		( (':' | '.') __ID_FIELD ) |
		'?' | '!'
	)*
;
__12 returns __Exp:
	__Prim
;
__Prim returns __Exp:
	( '(' __Exp ')' )
	//| a=Sizeof
	//| Var
	| Nat
	//| NULL
	//| Number
	//| STRING
	//| Global
	//| This
	//| Outer
	//| RawExp
	//| Vector_constr
	//| ('call' __Exp)
	//| ('call/rec' __Exp)
;

__Cast returns __Exp:
	Type | {Annotation} name=('@nohold' | '@plain' | '@pure');
	
Sizeof returns __Exp:
	'sizeof' '(' (=>Type | __Exp) ')'
;
Number:
	INT | FLOAT | HEX | 'true' | 'false';

Var:
	__ID_VAR
;
Nat:
	__ID_NAT
;
NULL:
	'null'
;
Global:
	'global'
;
This:
	'this'
;
Outer:
	'outer'
;
RawExp:
	'{' __raw '}'
;

__raw: // TODO
	'c-code'
;
Vector_constr:
	tups+=Vector_tup ( '..' (tups+=Vector_tup | exps+=__Exp) )*
;

Vector_tup:
	'[' ExpList ']'
;

Type:
	__ID_Type ( '&&' | '&' | '?' | ('[' (exp+=__Exp)? ']') )*;

__ID_Type returns Type:
	name=(TYPES | __ID_NAT | __ID_CLS_ADT);

ExpList returns __Exp:
	__Exp ({ExpList.first=current}',' next=__Exp)*
;

Finally:
	val=INT//Block
;



	*/