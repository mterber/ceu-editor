grammar org.xtext.ceu.Ceu with org.eclipse.xtext.common.Terminals

generate ceu "http://www.xtext.org/ceu/Ceu"

Root:
	Expression
;
	
	/*
Type:
	__ID_Type //( '&&' | '&' | '?' | ('[' (exp5+=Expression)? ']') )*;
	;
	* 
	*/
	
Type:
	SpecifierQualifierList AbstractDeclarator?
;

AbstractDeclarator:
	Pointer DirectAbstractDeclarator?
	| DirectAbstractDeclarator
;

DirectAbstractDeclarator:
	( '(' AbstractDeclarator ')' | AbstractDeclaratorSuffix) AbstractDeclaratorSuffix*
;

AbstractDeclaratorSuffix:
	'[' ']'
	| '[' LogicalOrExpression ']'
	| '(' ')'
;

Pointer:
	'*' TypeQualifier+ Pointer?
	| '*' Pointer
	| '*'
;

SpecifierQualifierList:
	(TypeQualifier | TypeSpecifier)+
;

TypeSpecifier:
	TYPES
;

TypeQualifier:
	'@nohold' | '@plain' | '@pure'
;

// -----------
// Expressions
// -----------
ArgumentExpressionList:
	first=AssignmentExpression (',' next+=AssignmentExpression)*
;

Expression:
	first=AssignmentExpression (',' next+=AssignmentExpression)*
;

AssignmentExpression returns Expression:
	Lvalue AssignmentOperator exp=AssignmentExpression
	| LogicalOrExpression
;

Lvalue returns Expression:
	UnaryExpression
;

AssignmentOperator:
	'='
;

LogicalOrExpression returns Expression:
	LogicalAndExpression ({LogicalOrExpression.left=current} 'or' right=LogicalAndExpression)*
;

LogicalAndExpression returns Expression:
	InclusiveOrExpression ({LogicalAndExpression.left=current} 'and' right=InclusiveOrExpression)*
;

InclusiveOrExpression returns Expression:
	ExclusiveOrExpression ({InclusiveOrExpression.left=current} '|' right=ExclusiveOrExpression)*
;

ExclusiveOrExpression returns Expression:
	AndExpression ({ExclusiveOrExpression.left=current} '^' right=AndExpression)*
;

AndExpression returns Expression:
	EqualityExpression ({AndExpression.left=current} '&' right=EqualityExpression)*
;

EqualityExpression returns Expression:
	RelationalExpression ({EqualityExpression.left=current} ('==' | '!=') right=RelationalExpression)*
;

RelationalExpression returns Expression:
	ShiftExpression ({RelationalExpression.left=current} ('<' | '>' | '<=' | '>=') right=ShiftExpression)*
;

ShiftExpression returns Expression:
	AdditiveExpression ({ShiftExpression.left=current} ('<<' | '>>') right=AdditiveExpression)*
;

AdditiveExpression returns Expression:
	MultiplicativeExpression ({AdditiveExpression.left=current} ('+' | '-') right=MultiplicativeExpression)*
;

MultiplicativeExpression returns Expression:
	CastExpression ({MultiplicativeExpression.left=current} ('*' | '/' | '%') right=CastExpression)*
;

CastExpression returns Expression:
	'(' Type ')' right=CastExpression
	| UnaryExpression
;

UnaryExpression returns Expression:
	PostfixExpression
	| UnaryOperator CastExpression
	| 'sizeof' ('(' Type ')' | UnaryExpression) 
;

PostfixExpression returns Expression:
	PrimaryExpression
	(
		'[' exp3+=Expression ']'
		| ('(' ')' | '(' exp2+=ArgumentExpressionList ')') ('finalize' 'with' finally+=Finally 'end')?
		| (':' | '.') __ID_FIELD
		| '?'
		| '!'
	)*
;

UnaryOperator:
	'not' | '-' | '+' | '~' | '*' | '&&' | '&' | '$$' | '$'
;

PrimaryExpression returns Expression:
	'(' Expression ')'
	| __ID_VAR
	| __ID_NAT
	| Number
;

Finally:
	val=INT
;

Number:
	INT | FLOAT | HEX | 'true' | 'false';
	
__ID_Type:
	name=(TYPES | __ID_NAT | __ID_CLS_ADT);

terminal TYPES:
	'bool' | 'byte' | 'char' | 'f32' | 'f64' | 'float' | 'int' | 's16' | 's32' | 's64' | 's8' | 'u16' | 'u32' | 'u64' |
	'u8' | 'uint' | 'void' | 'word';
	
terminal __ID_VAR:
	'a'..'z' ALPHANUM*;

terminal __ID_EXT_TAG:
	'A'..'Z' ALPHANUM_L*;

terminal __ID_CLS_ADT:
	'A'..'Z' ALPHANUM*;

terminal __ID_NAT:
	'_' ALPHANUM+;

terminal __ID_FIELD:
	ALPHA ALPHANUM*;
	
terminal HEX:
	'0' ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;

terminal FLOAT:
	INT '.' INT (('e' | 'E') '-'? INT)?;

terminal fragment ALPHA: // Alpha
	'a'..'z' | '_' | 'A'..'Z';

terminal fragment ALPHANUM: // Alphanum
	ALPHA | '0'..'9';

terminal fragment ALPHANUM_L: // ALPHANUM
	'A'..'Z' | '_' | '0'..'9';

terminal fragment ALPHANUM_S: // alphanum
	'a'..'z' | '_' | '0'..'9';